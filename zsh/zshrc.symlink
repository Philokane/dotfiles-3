# shortcut to this dotfiles path is $ZSH
export ZSH=$HOME/.dotfiles

# your project folder that we can `c [tab]` to
export PROJECTS=~/Sites

# use .localrc for SUPER SECRET CRAP that you don't
# want in your public, versioned repo.
if [[ -a ~/.localrc ]]
then
  source ~/.localrc
fi

# all of our zsh files
typeset -U config_files
config_files=($ZSH/**/*.zsh)

# load the path files
for file in ${(M)config_files:#*/path.zsh}
do
  source $file
done

# load everything but the path and completion files
for file in ${${config_files:#*/path.zsh}:#*/completion.zsh}
do
  source $file
done

# initialize autocomplete here, otherwise functions won't be loaded
autoload -U compinit
compinit

# load every completion after autocomplete loads
for file in ${(M)config_files:#*/completion.zsh}
do
  source $file
done

unset config_files

### Added by the Heroku Toolbelt
export PATH="/usr/local/heroku/bin:$PATH"

export PATH=/Users/andrewwalker/Development/adt-bundle-mac-x86_64-20131030/sdk/tools:/Users/andrewwalker/Development/adt-bundle-mac-x86_64-20131030/sdk/platform-tools:$PATH

# unalias run-help
# autoload run-help
# HELPDIR=/usr/local/share/zsh/helpfiles

export RBENV_ROOT=/usr/local/var/rbenv

source $HOME/.zshenv

setopt INC_APPEND_HISTORY

#source ./plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
#source ./plugins/zsh-history-substring-search/zsh-history-substring-search.zsh

#export PROMPT_COMMAND=long-command-alert
#trap '[ -z ${LAST_COMMAND_TIME} ] && export LAST_COMMAND_TIME=$(date +%s)' DEBUG

preexec () {
    # Note the date when the command started, in unix time.
    CMD_START_DATE=$(date +%s)
    # Store the command that we're running.
    CMD_NAME=$1
}
precmd () {
    # Proceed only if we've ran a command in the current shell.
    if ! [[ -z $CMD_START_DATE ]]; then
        # Note current date in unix time
        CMD_END_DATE=$(date +%s)
        # Store the difference between the last command start date vs. current date.
        CMD_ELAPSED_TIME=$(($CMD_END_DATE - $CMD_START_DATE))
        # Store an arbitrary threshold, in seconds.
        CMD_NOTIFY_THRESHOLD=30

        if [[ $CMD_ELAPSED_TIME -gt $CMD_NOTIFY_THRESHOLD ]]; then
            # Beep or visual bell if the elapsed time (in seconds) is greater than threshold
            afplay ~/.dotfiles/media/program-complete.wav -v 2
            # Send a notification
            growlnotify -t "Program complete" -m "\"$CMD_NAME\" finished in $CMD_ELAPSED_TIME seconds."
        fi
    fi
}
